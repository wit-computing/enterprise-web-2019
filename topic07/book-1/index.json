


  {
  
  
    "properties" : {},
  
  "type" : "lab",
  "title" : "Lab-node1",
  "img" : "img/main.png",
  "videoid" : "none",
  "objectives" : "<p>This lab introduces <strong>node.js</strong> as a server-side technology. You will use node.js to run javascript programs on the &quot;server-side&quot; which are capable of servicing HTTP requests. </p>",
  "folder" : "book-1",
  "link" : "index.html",
  "los": [
   ]
,
  "chapters" : [
  
    {
    "title": "# Node and Express 1",
    "shortTitle": "Lab-node1",
    "contentMd" : "# Node and Express 1\r\n\r\nThis lab introduces **node.js** as a server-side technology. You will use node.js to run javascript programs on the \"server-side\" which are capable of servicing HTTP requests. \r\n\r\nYou will learn how to:\r\n\r\n- Create and use a remote repo on Github\r\n- Set node up as a HTTP server.\r\n- Use Node's built in http module to create a simple HTTP server.\r\n- Node's packaging system.\r\n- How to host your existing web resources in a Node.js HTTP server.\r\n- How to do a simple route for a HTTP request.\r\n"
    },
  
    {
    "title": "# Get Git",
    "shortTitle": "01",
    "contentMd" : "# Get Git\r\n\r\n![git](./img/git1.png)\r\n\r\nYou will probably have git from the previous labs. If not, follow the instructions for your operating system.\r\n### Windows OS\r\nIf you're on Windows, download the  **GitHub Desktop**, from [here](https://desktop.github.com/) which includes Git, and use the Git Shell for your terminal.\r\n\r\n\r\n### Mac\r\nYou can install Git automatically. To do this, open the Terminal application from spotlight and type `git`. This will prompt Git to install the rest of the command line tools for Git. This should only take a few minutes. It will ask if you would like to download Xcode, which you can ignore.\r\n\r\n### Linux\r\n\r\nYou can use the package-management tool that comes with your distribution. For Fedora use:\r\n\r\n~~~bash\r\n$ sudo yum install git-all \r\n~~~\r\n\r\nFor Debian use:\r\n\r\n~~~bash\r\n$ sudo apt-get install git-all\r\n~~~\r\n\r\n## Tell Git who you are\r\nYou will need to configure git with your identity so that it can record your git activity such as repo creation and changes. To set a global identity for all repos on the machine, enter the following:\r\n~~~bash\r\n$ git config --global user.email \"your@email.com\"\r\n$ git config --global user.name \"Your Name\"\r\n~~~\r\n\r\n## Clone a Repository\r\n\r\n### Clone the samples repository\r\nSelect a location on your machine where you would like to keep the code examples taken from the weekly talks. Open a terminal window in that location and clone the samples repository:\r\n\r\n```\r\ngit clone https://github.com/fxwalsh/ewd-examples-2019.git\r\n```\r\n\r\nThis should create a new folder called *ewd-examples-2019*. Open the folder and you should see the node samples from the lecture slides. We will use this repository for our example code as the module progresses. You will need to *pull* the repository from time to time to get the latest code examples from the lectures.\r\n\r\n## Create a repository\r\nYou can think of a repository as a project folder with all the related files inside of it.\r\n![git repos](./img/repos.png)\r\nYou intialise a folder as a  Git repository and Git will start tracking the changes to that folder. Any files added, removed or changed are tracked and time stamped by Git. That's version control.\r\n\r\nYou're going to create a new folder and initialize it as a Git repository.\r\nMake a new folder by opening a terminal window at a suitable  location on your machine. Enter the follwoing commands to make a new directory called *ewd-node-labs-2019* and then change directory into it :\r\n~~~bash\r\n$ mkdir ewd-node-labs-2019\r\n$ cd ewd-node-labs-2019\r\n~~~\r\n\r\nNow initialise the folder as a Git repo:\r\n~~~\r\n$ git init\r\n~~~\r\nTo check that it's a Git repository, type ``git status`` and if returns something like 'On branch master ....', you've got a new local repo!\r\n\r\n## Add to the repository\r\nOpen a text editor. Now write a couple of lines of text:\r\n\r\n~~~text\r\n# Node Development Practical Labs\r\n~~~\r\n\r\nand save the file as ``readme.md`` in the *ewd-node-labs-2019* folder.\r\n\r\n## Status, Add and Commit Changes\r\nNext check the status of your repository to find out if there have been changes. In the terminal, you should still be within the 'ewd-node-labs-2019' directory. Enter ``git status`` for a report on any changes listed:\r\n\r\n~~~bash\r\n$ git status\r\n~~~\r\n![Git Status](./img/git-status.png)\r\n\r\nYou can see that the *readme.md* file is untracked at the moment. Add it to the files you'd like to track with Git.\r\n\r\n~~~bash\r\n$ git add readme.md\r\n~~~\r\n\r\nFinally, commit those changes to the repository's history with a short description of the updates.\r\n\r\n~~~bash\r\n$ git commit -m \"Created the readme file\"\r\n~~~\r\n\r\n### Make More Changes\r\n\r\nNow add another line to *readme.md* and save.\r\n\r\nIn terminal, you can view the difference between the file now and how it was at your last commit using ``git diff``.\r\n\r\n![Git Diff](./img/git-diff.png)\r\n\r\nNow, what you just learned above, commit this latest change.\r\n"
    },
  
    {
    "title": "# Github",
    "shortTitle": "02",
    "contentMd" : "# Github\r\nThe repository you've created so far is just on your computer, which is handy, but makes it pretty hard to share and work with others on.\r\n\r\n## Create a GitHub Account\r\nGitHub is a website that allows people everywhere to upload what they're working on with Git and to easily work together.\r\n\r\nVisit [github.com](http://github.com) and sign up for a free account.\r\n\r\n## Add username to Git\r\n\r\nAdd your GitHub username to your Git configuration, which will be needed in order to push the upcoming labwork to Github. Save it exactly as you created it on GitHub â€” capitalise where capitalised, and remember you don't need to enter the \"<\" and \">\" .\r\n\r\nAdd your GitHub username to your configuration:\r\n\r\n~~~bash\r\n$ git config --global user.username <YOUR_GITHUB_USERNAME>\r\n~~~\r\n\r\n## Remote Repository\r\nWhen you put files on GitHub, that copy lives on one of GitHub's servers. This makes it a *remote* repository because it is not on your computer. You need to *push* your local (on your computer) changes to it, you keep it up to date.\r\n\r\nOthers can always get the latest from your project by pulling your changes down from the remote (and onto their computer). In fact, this is how you will get the weekly updates to the code examples repo. It is also how you can collaborate with others.\r\n\r\n### Create a Remote Repository\r\n\r\nYou want to sync your local version with one stored on GitHub.com called the *remote* version. So first create an empty remote repository on GitHub.com.\r\n\r\nGo to github.com, log in, and click the '+' in the top right to create a new repository.\r\nGive it a name that matches your local repository's name, ***ewd-node-labs-2019***, and a short description.\r\nSelect the following options:\r\n- make it public or private as you see fit.\r\n- **don't** create a readme.md (you have one already in your local repo).\r\n- create a .gitignore and select the *Node* option in the dropdown.\r\nClick create repository and you should be taken to your new repo page. \r\n- Copy the URL from the \"clone or download\" option on the repo page.  You will need the URL of the repo to connect your local repo to this *remote* repo.\r\n![Repo URL](./img/repo-url.png)\r\n### Connect your Local to your Remote\r\n\r\nNow you've got a remote repository on GitHub.com, back in your terminal in 'ewd-node-labs-2019' folder, you want to tell Git the location of the remote version on GitHub's servers. You can have multiple remotes so each requires a name. For your main one, this is commonly named *origin*.\r\n\r\n~~~bash\r\n$ git remote add origin <YOUR_URL_FROM_GITHUB>\r\n~~~\r\n\r\nYour local repository now knows where your remote one named 'origin' is (i.e. on GitHub). T\r\n\r\n>    A note:\r\n>    \r\n>    If you have GitHub for Windows on your computer, a remote named 'origin' is automatically created. In that case, you'll just need to tell it what URL to associate with origin. Use this command instead of the 'add' one above:\r\n>    \r\n>    $ git remote set-url origin <YOUR_URL_FROM_GITHUB>\r\n\r\n### Pull down the changes on the remote repo\r\nYou created a .gitignore file on the remote repo. You need to *pull* this change into your local repo. Git has a branching system so that you can work on different parts of a project at different times but by default the first branch is named 'master'. When you pull (and push) from a project, you tell Git the branch name you want and the name of the remote that it lives on.\r\n- Enter the following command to pull the remote changes into the master branch on your local repo:\r\n~~~bash\r\n$ git pull origin master --allow-unrelated-histories\r\n~~~ \r\n- The ``--allow-unrelated-histories`` needs to be included as the local and remote repositories were created independently and have some commits.\r\n\r\nNow we will *push* your local work (i.e. the readme.md) to the remote repo. \r\n\r\n### Push Work to your Remote\r\n\r\nNext you want to push (send) everything you've done locally to GitHub. Ideally you want to stay in sync, meaning your local and remote versions match.\r\n\r\nSimilar to a pull, when you push from a project you tell Git the branch name you want to push and the name of the remote that it lives on.\r\n\r\nIn this case, we'll send our branch named 'master' to our remote on GitHub named 'origin'.\r\n\r\n~~~bash\r\n$ git push origin master\r\n~~~\r\n\r\nNow go to GitHub and refresh the page of your repository. Everything is the same locally and remotely. You should see the following in your local repo:\r\n\r\n![Empty Local Repo](./img/git_repo_init.png)\r\n\r\nCongrats on your first public repository! You will use this repository to contain the rest of your lab work.\r\n"
    },
  
    {
    "title": "# Development Dependencies",
    "shortTitle": "03",
    "contentMd" : "# Development Dependencies\r\nWe will now set up and configure a development environment for Node.js. \r\n\r\n\r\n## package.json\r\nIf you're developing a Node program or library for deployment, it's standard practice to include a **package.json** file. This file is the **manifest of the Node project** and is located at your project root. It contains various information specific to your project such as module dependencies and scripts. \r\n\r\n\r\n\r\n- Create a new folder called *node_lab1* in your new repo.\r\n![Empty Local Repo](./img/git_repo_lab1.png)\r\n- Open a terminal window in *node_lab1* and enter the following command:\r\n\r\n~~~bash\r\nnpm init\r\n~~~\r\n\r\n- You will be prompted for details. Enter the following:\r\n\r\n~~~\r\nname: (lab1) node-lab1\r\nversion: (1.0.0) \r\ndescription: node lab 1\r\nentry point: (index.js)\r\ntest command:\r\ngit repository: \r\nkeywords:\r\nauthor: YOUR_GIT_USERNAME\r\nlicense: (ISC)\r\n~~~\r\n\r\nYou should now see a ``package.json`` file in the lab directory with these details.\r\n\r\n## Babel\r\n\r\nWe will be writing our Javascript using ES2015 so we require transcoding before our Node app runs. We need to bring in some babel packages to handle this.\r\n\r\n- Enter the following command to get the relevant babel package and relevant  presets.\r\n\r\n~~~bash\r\nnpm install --save-dev babel-cli\r\nnpm install --save-dev babel-preset-env\r\n~~~\r\n\r\nThe ``--save-dev`` will write this dependency to the development section of the package.json. Have a look at the *package.json* file and you will now see the dev dependency on babel as highlighted below:\r\n\r\n![Development Dependencies](./img/package.PNG)\r\n\r\n\r\n\r\n- To configure babel to transcode from es2015, create a file called **.babelrc** in the **node-lab1** folder and enter in the following:\r\n~~~json\r\n{\r\n  \"presets\": [\"env\"]\r\n}\r\n~~~\r\nNow have a look at the  *package.json* file. You'll see that the babel development dependencies are specified.  \r\n\r\n## Nodemon\r\nWhen we change things in a Node.js project, a restart is required for the changes to be reflected in the running process. This can be very time consuming. Instead of manually restarting Node, we will install the ``nodemon`` package as a **development dependency**, which can monitor our files and auto-restart Node for us when we save changes to disk.\r\n\r\n- Install Nodemon:\r\n~~~bash\r\nnpm install --save-dev nodemon\r\n~~~\r\n\r\n## Commit it\r\n\r\nNow that we have a our basic setup and configuration complete,this is a good time to commit your changes to git.\r\n\r\n- In the directory *ewd-node_labs_2019* run the following:\r\n~~~bash\r\ngit add --all\r\ngit commit -m \"set up and initial configuration\"\r\n~~~\r\n\r\nYou should **NOT** see any output indicating changes ignored file and folders, for example the *node_modules*. We do not need to track changes here as it's contents are specified in the *package.json*.\r\n"
    },
  
    {
    "title": "# The "Hello World" HTTP Server",
    "shortTitle": "04",
    "contentMd" : "# The \"Hello World\" HTTP Server\r\n\r\nWe will be using node as a web API platform. In this step we'll set up a simple HTTP server that responds to every request with the plain text message \"Hello World\".\r\n\r\n## App Config\r\n\r\nAs discussed in class, one of the advantages of NPM is the wide availability of handy utility packages that follow accepted best practice. App configuration management and environment variables are common to many apps. When using public, cloud based repos you should use best practice approaches to keep sensitive parameters such as private keys and passwords safe.  \r\n\r\nDotenv is a zero-dependency module that loads environment variables from a .env file into *process.env*. In doing this Dotenv stores configuration in the environment separate from code is based on \"The Twelve-Factor App\" methodology.\r\nThis simple application just needs some typical configuration details, for example the port and host info.\r\n\r\n- Install Dotenv as a normal, runtime dependency\r\n~~~bash\r\nnpm install dotenv --save\r\n~~~\r\n\r\n- Create a new file in your application root folder called **.env** and add the following content:\r\n~~~javascript\r\nNODE_ENV=development\r\nPORT=8080\r\nHOST=localhost\r\n~~~\r\n\r\nAs you could be putting sensitive stuff in the .env file, you should **NOT** commit your .env file to version control. It should only include environment-specific values such as database passwords or API keys used by your server-side API. Also, your production database should have a different password than your development database.\r\n\r\nTo ensure this is the case, do the following:\r\n\r\n- Open *.gitignore* file in you *node-labs-2018* folder. Check that it contains the following entry:\r\n~~~json\r\n# dotenv environment variables file\r\n.env\r\n~~~\r\n\r\n## HTTP service\r\n\r\n- In the *node-lab1* create a new file called  *index.js*  with the following contents:\r\n\r\n~~~javascript\r\n\r\n// Load the http module to create an http server.\r\nimport http from 'http';\r\nimport dotenv from 'dotenv'\r\n\r\ndotenv.config()\r\n\r\nconst port = process.env.PORT\r\n// Configure our HTTP server to respond with Hello World to all requests.\r\nconst server = http.createServer((req, res) => {\r\n  res.writeHead(200, {'Content-Type': 'text/plain'});\r\n  res.end('Hello  World!');\r\n});\r\n\r\nserver.listen(port);\r\n\r\n// Put a friendly message on the terminal\r\nconsole.log(`Server running at ${port}`);\r\n~~~\r\nIn the first line, we import the http core module and assign it to ``http``. Next we assign the variable  ``server`` from the ``http.createServer(...)`` function. The argument passed into this call is the function that is called whenever an http request comes in.\r\nFinally we call ``server.listen(config.port)`` to tell node.js the port on which we want our server to run.\r\n\r\n## Startup Script\r\nWe want to specify a script to start up the Node server, which will be the **index.js** file. So our start script would be ``node index.js``. However, since we want the code to be transcoded using  babel and started with nodemon, we will add a **nodemon** execution wrapper and use **babel-node** instead of the node command.\r\n\r\n- Find the ``scripts`` property in the *package.json* file and replace it with the following: \r\n\r\n~~~json\r\n....\r\n\"scripts\": {\r\n    \"start\": \"nodemon --exec babel-node index.js\"\r\n  },\r\n....\r\n~~~\r\n\r\nTo run the server open a terminal/command window in the node-lab1 folder and enter:\r\n\r\n~~~bash\r\nnpm start\r\n~~~\r\n\r\nYou should see output smilar to the following:\r\n\r\n![Node Start](./img/node-start.png)\r\nNow open your browser to 'http://localhost:8080'. You should see the following:\r\n![Node Hello World](./img/hello_world.png)\r\n\r\n\r\nThe connection function is invoked with a **req** and **res** object. The **req** object represents the HTTP request and is a readable stream that emits 'data' events for each incoming piece of data (like a form submission or file upload). The ***res*** object represents the HTTP response and is used to send data back to the client. In our case we are simply sending a 200 OK header, as well as the body 'Hello World'.\r\n\r\nLeave the app running for the next section.\r\n\r\n## Nodemon in Action\r\n\r\nNow that your node app is running using Nodemon, any saved changes to your source code(index.js) will cause the app to restart automatically.\r\n\r\n- Change ``index.js`` to return \"Hello EWD!\" in the response and take a look at the terminal. You should see the console output indicating a restart. However, you will require a refresh in the browser to see the new \"Hello EWD!\" message."
    },
  
    {
    "title": "# Linting",
    "shortTitle": "05",
    "contentMd" : "# Linting\r\nIt'd be nice to get feedback on the quality of your Javascript code as you write it. ESLint is a tool for identifying and reporting on patterns found in ECMAScript/JavaScript code. It can be used to detect syntax errors in the editor and also to enforce code styles, for example the use of semicolons at the end of each statement.\r\n\r\n- Install ESLint as follows:\r\n~~~bash\r\nnpm install --save-dev eslint babel-eslint\r\n~~~\r\n\r\n- To configure ESLint, enter the following at the command line:\r\n~~~bash\r\nnpx eslint --init\r\n~~~\r\n\r\n- Answer the resulting questions as follows:\r\n\r\n![ESLint Config](./img/eslint.png)\r\n\r\nYou should now see a file called *.eslintrc.json* in the *node-lab1* folder.\r\n\r\n- Open *.eslintrc.json* and replace the ``rules`` property with the following: \r\n\r\n~~~json\r\n\"rules\": {\r\n        \"semi\": 1,\r\n        \"no-console\": \"off\"\r\n    }\r\n~~~\r\n\r\nThe *.eslint.json* file specifies that we wish to lint ES6 Javascript in module format (uses imports and exports). We also specify the environment is Node.js with associated global variables and Node.js scoping. Finally, we add some rules that warn if you leave out a semicolon and permit the use of ``console.log()`` (we should really use a proper logging module...).\r\n\r\nYou've now set your project folder up for linting your Javascript files.\r\n\r\n> NOTE: These linting rules are to keep your code style consistent. If you already use JS and you wish to follow other rules (with justification) then feel free to implement them here. For example, a lot of JS developers do not use the semicolon at the end of each statement (as you've seen in index.js, you don't need it!)\r\n\r\n### How bad is your code?\r\nNow lets check your code using ESLint on the command line.\r\n\r\n- Run the following command to lint your code:\r\n~~~bash\r\nnpx eslint index.js\r\n~~~\r\nThe rules will warn you if any statement does not end with a semicolon. The linter should highlight this and you should see the following output:\r\n![Node Hello World](./img/linter.png)\r\nYou can fix manually or use the command ``npx eslint index.js --fix`` to resolve the problems(if the linter suggests it).\r\nWhen the code is in good order, the linter should return nothing. Nice code!\r\n\r\n## Linting in VS Code\r\n\r\nIf you use the VS Code editor you can install the **ESLint Extension** so that the editor will highlight issues as you type. \r\n\r\nDo ``control-shift-x`` search for \"ESLint\" and install. It will automatically pick up the ESLint config of your folder...\r\n\r\n![ESLint in VS Code](./img/eslint2.png)\r\n\r\n## Commit your changes\r\n- Commit the changes you have just made using git.\r\n~~~bash\r\ngit add -A\r\ngit commit -m \"node-lab1,  simple server\"\r\n~~~\r\n"
    },
  
    {
    "title": "# The Module System",
    "shortTitle": "06",
    "contentMd" : "# The Module System\r\nNode.js provides a simple module system that lets you structure your program into different files. In our *index.js* example, we use the core http module to create our HTTP service. You can also write your own modules. When creating a module, this can be interpreted as moving all related functions into a file.\r\n\r\n- Create a new file called 'greeting.js' in the same folder with the following content:  \r\n\r\n~~~javascript\r\nconst greeting = {\r\n    en: \"Hello World!\",\r\n    fr: \"Bonjour!\"\r\n}\r\n\r\nexport default greeting;\r\n~~~\r\n\r\n- Update your *index.js* file as follows:\r\n\r\n~~~javascript\r\n// Load the http module to create an http server.\r\nimport http from 'http';\r\nimport dotenv from 'dotenv';\r\nimport greeting from './greeting.js';\r\n\r\ndotenv.config();\r\nconst port = process.env.PORT;\r\n\r\n// Configure our HTTP server to respond with Hello World to all requests.\r\nconst server = http.createServer((req, res) => {\r\n  let lang = req.headers['accept-language'];\r\n  const defaultLang='en';\r\n  if (!greeting[lang]) lang=defaultLang;\r\n  const response={\r\n    lang: lang,\r\n    message: greeting[lang],\r\n  };\r\n\r\n  res.writeHead(200, {'Content-Type': 'text/plain',\r\n                      'Content-Language': response.lang});\r\n  res.end(response.message);\r\n});\r\n\r\nserver.listen(port);\r\n\r\n// Put a friendly message on the terminal\r\nconsole.log(`Server running at ${port}`);\r\n~~~\r\n\r\n\r\nNow test your file again using a browser. The ``export`` expose greeting to other modules that require them. To access the exported functions in our simple server, we can load the greeting module using the require function in ``import greeting from ('./greeting');``. The server gets the accepted language from the requesting process using ``req.headers[\"accept-language\"]`` . To set the accept-language HTTP header of the request:\r\n\r\n- install a suitable REST client. This lab will opt for [Postman](https://www.getpostman.com/).\r\n- Perform a **HTTP GET** request to **localhost:8080** with ``Accept-language=fr``.\r\n\r\nYou should see the French representation for the greeting returned in the response.\r\n\r\n> ![Greeting in French](./img/greeting_in_french.png)\r\n\r\nAs you will see, the core modules give you very few modules. Most of the real power in Node.js is contained in the third party modules available through the Node Package Management system(NPM).\r\n\r\n### Commit your changes\r\n- Commit the changes you have just made using git.\r\n~~~bash\r\ngit add -A\r\ngit commit -m \"node-lab1,  greeting module added\"\r\n~~~\r\n"
    },
  
    {
    "title": "# Express Applications",
    "shortTitle": "07",
    "contentMd" : "# Express Applications\r\n\r\nWe'll now add some static content to our web server. Up to now you've used **http-server** which is fine for prototyping HTML. We'll now move to Express, a richer web app package and provides a nice high level approach to serving up static content. It's based around the idea of creating an Express \"app\" that you can easily configure. One of the configuration options allows you to specify the location of your publicly available content such as static HTML, CSS, client-side Javascript files etc.\r\n\r\n## Express\r\nTo create an Express app, we need to install it as a **normal dependency**.\r\n\r\n- Install the express package.\r\n~~~bash\r\nnpm install --save express\r\n~~~\r\n\r\nThe ``--save`` flag will write this dependency to package.json.\r\n\r\n- In your *node-lab-1* folder, create the following folder structure:\r\n~~~\r\n+public\r\n    |-javascript\r\n    |-stylesheets\r\n~~~\r\n- Get the solution to the [*html/css lab*](./files/static.zip) and place the files directly into the *public* folder(the *index.hmtl* file should in the *public* folder).\r\n- In node-lab-1, replace the contents of **index.js** with the following javascript:\r\n\r\n~~~javascript\r\n\r\nimport dotenv from 'dotenv';\r\nimport express from 'express';\r\n\r\ndotenv.config();\r\n\r\nconst server = express();\r\n\r\nconst port = process.env.PORT;\r\n\r\nserver.use(express.static('public'));\r\n\r\nserver.listen(port, () => {\r\n  console.info(`Server running at ${port}`);\r\n});\r\n\r\n~~~\r\n\r\n- Now test the application as before in a browser. It should display the default resource (index.html) from the public folder.\r\n\r\n## Simple Routing using Express\r\nExpress gives us an easy way of mapping specific URL paths to Javascript functions. You will now replicate the functionality from the \"Hello World\" section so that a **HTTP GET** request for the URL path  '/greeting/' will respond with \"Hello World\". Modify the index.js by adding an ``app.get([route],[callback function])``.\r\n- Modify the index.js script to include a route for /greeting that responds with \"hello world\".\r\n\r\n~~~javascript\r\nimport dotenv from 'dotenv';\r\nimport express from 'express';\r\nimport greeting from './greeting';\r\n\r\ndotenv.config();\r\n\r\nconst app = express();\r\n\r\nconst port = process.env.PORT;\r\n\r\napp.use(express.static('public'));\r\n\r\n// add route for /greeting\r\napp.get('/greeting', (req, res)=>{\r\n  let lang = req.headers['accept-language'];\r\n  const defaultLang='en';\r\n  if (!greeting[lang]) lang=defaultLang;\r\n  const response={\r\n    lang: lang,\r\n    message: greeting[lang],\r\n  };\r\n\r\n  res.writeHead(200, {'Content-Type': 'text/plain',\r\n                      'Content-Language': response.lang});\r\n  res.end(response.message);\r\n});\r\n\r\n\r\napp.listen(port, () => {\r\n  console.info(`Server running at ${port}`);\r\n});\r\n~~~\r\n## Commit and Push to Github\r\nCommit your changes using git as before and push your changes to your remote repository.\r\n\r\n~~~script\r\ngit add -A\r\ngit commit -m \"node1-lab, changed to express app\"\r\ngit push origin master\r\n~~~\r\n\r\n### Contacts API\r\n\r\n Ultimately we would like our API to use a database such as Mongo and allow for a more realistic API that can cope with large volumes of data you would expect in a production environment.\r\n\r\nCreate a new folder called **api** in **node-lab-1**. Create another folder called **contacts** in **api**. Your folder structure should look as follows:\r\n\r\n~~~\r\n+node-lab-1\r\n    |-api\r\n       |-contacts\r\n~~~\r\n\r\nWe will use test data for the time being. \r\n\r\n- Create a new file called **contacts.js** in the contacts folder and add the following code:\r\n\r\n~~~javascript\r\nexport const contacts = [\r\n  {\r\n    'name': 'Contact 1',\r\n    'address': '123 Test St',\r\n    'phone_number': '132-3212',\r\n  },\r\n  {\r\n    'name': 'Contact 2',\r\n    'address': '23 Main St',\r\n    'phone_number': '934-4329',\r\n  },\r\n  {\r\n    'name': 'Contact 3',\r\n    'address': '4 Lower St',\r\n    'phone_number': '432-5832',\r\n  },\r\n  {\r\n    'name': 'Contact 4',\r\n    'address': '49 Upper Street',\r\n    'phone_number': '934-4290',\r\n  },\r\n];\r\n~~~\r\n\r\n- Also in the contacts folder, create a new file called **index.js** and enter the following javascript:\r\n\r\n~~~javascript\r\nimport express from 'express';\r\nimport {contacts} from './contacts';\r\n\r\nconst router = express.Router(); // eslint-disable-line\r\nrouter.get('/', (req, res) => {\r\n  res.send({contacts: contacts});\r\n});\r\n\r\nexport default router;\r\n~~~\r\n\r\n\r\n- Now update **index.js** in the root folder to use the new contacts routing script by replacing the contents with the following code\r\n\r\n~~~javascript\r\nimport dotenv from 'dotenv';\r\nimport express from 'express';\r\nimport contactsRouter from './api/contacts';\r\n\r\ndotenv.config();\r\n\r\nconst app = express();\r\n\r\nconst port = process.env.PORT;\r\n\r\napp.use(express.static('public'));\r\n\r\napp.use('/api/contacts', contactsRouter);\r\napp.use(express.static('public'));\r\n\r\napp.listen(port, () => {\r\n  console.info(`Server running at ${port}`);\r\n});\r\n~~~\r\n\r\nNow test the application again by doing a HTTP GET on ``localhost:8080/api/contacts``. You should see something simlilar toe the following:\r\n\r\n![Get contact details](./img/contacts_api_1.png)\r\n\r\n### Challenge\r\n\r\n- Try to include in server-side route for the Hacker News lab you did last week. Follow the same procedure as above.\r\n\r\n> hint: create a new folder in api for Hacker News. Create a routing script and update index.js to add the Hacker News route.\r\n"
    }
  
  ]
  }

