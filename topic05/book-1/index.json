


  {
  
  
    "properties" : {},
  
  "type" : "lab",
  "title" : "Lab-Interactive_Apps",
  "img" : "img/main.jpg",
  "videoid" : "none",
  "objectives" : "<p>Continue the development of the three SPAs by adding <strong>statefulness</strong> and making them <strong>interactive and dynamic</strong>.</p>",
  "folder" : "book-1",
  "link" : "index.html",
  "los": [
   ]
,
  "chapters" : [
  
    {
    "title": "# Building React SPAs (Dynamic).",
    "shortTitle": "Lab-Interactive_Apps",
    "contentMd" : "# Building React SPAs (Dynamic).\r\n \r\nContinue the development of the three SPAs by adding __statefulness__ and making them __interactive and dynamic__.\r\n"
    },
  
    {
    "title": "## Startup.",
    "shortTitle": "Startup",
    "contentMd" : "## Startup.\r\n\r\nUse the code developed in the previous lab (the `threeApps` folder) as the starting point for this one."
    },
  
    {
    "title": "## Contact List App.",
    "shortTitle": "Contact_List",
    "contentMd" : "## Contact List App.\r\n\r\nThe objective is to allow the user edit or delete an existing contact, with the option to undo / cancel the operation, if required. We also want to enable the addition of new contacts to the list.\r\n\r\n### Stub API\r\n\r\nIn production mode a SPA gets its model data from a 'real' web API. However, during development a __stub API__ is a common technique, either because the API is not yet developed or to postpone integration until the SPA is complete. \r\n\r\nCreate the file `contactlist/src/dataStore/stubAPI.js` and add the following code:\r\n\r\n      import _ from 'lodash';\r\n\r\n      class StubAPI {\r\n          constructor() {\r\n              this.contacts = [\r\n                  {\r\n                  'name': 'Contact 1',\r\n                  'address': '123 Test St',\r\n                  'phone_number': '132-3212'\r\n                  },        \r\n                  {\r\n                  'name': 'Contact 2',\r\n                  'address': '23 Main St',\r\n                  'phone_number': '934-4329'\r\n                  }, \r\n                  {\r\n                  'name': 'Contact 3',\r\n                  'address': '4 Lower St',\r\n                  'phone_number': '432-5832'\r\n                  },\r\n                  {\r\n                  'name': 'Contact 4',\r\n                  'address': '49 Upper Street',\r\n                  'phone_number': '934-4290'\r\n                  },\r\n                  {\r\n                  'name': 'Contact 5',\r\n                  'address': '4 High Street',\r\n                  'phone_number': '933-3390'\r\n                  }\r\n              ] ; \r\n          }\r\n\r\n          delete(k) {\r\n              let elements = _.remove(this.contacts, \r\n                  (contact) => contact.phone_number === k\r\n              );\r\n              return elements; \r\n          }\r\n          getAll() {\r\n              return this.contacts ;\r\n          }\r\n\r\n          add(n,a,p) {\r\n              let len = this.contacts.length ;\r\n              let newLen = this.contacts.push({\r\n                  name: n, address : a, phone_number: p }) ;\r\n              return newLen > len ;\r\n          }\r\n\r\n          update(key,n,a,p) {\r\n              let index = _.findIndex(this.contacts, \r\n                  (contact) => contact.phone_number === key\r\n              );      \r\n              if (index !== -1) {\r\n                  this.contacts.splice(index, 1, \r\n                      {name: n, address: a, phone_number: p});\r\n                  return true ;\r\n              }\r\n              return false ;\r\n          }\r\n      }\r\n\r\n      export default (new StubAPI() );\r\n         \r\nThis code uses the *lodash* utility package. To install it, in the terminal window go to the `contactList` folder and type:\r\n\r\n       $ npm install  lodash@2.4.2 --save\r\n\r\n[This installs the package in `node_modules` and updates (--save) the local `package.json` file.]\r\n\r\nStart the development server from the `contactlist` folder:\r\n\r\n       $ npm start\r\n\r\nIn `contactlist/src/App.js`, the App component should now get the sample model data from the stub API. Replace the entire content of the file with the following: \r\n\r\n      import React , { Component } from 'react';\r\n      import './App.css';\r\n      import Header from './components/header' \r\n      import ContactForm from './components/contactForm' \r\n      import ContactList from './components/contactList' \r\n      import api from './dataStore/stubAPI'  // NEW\r\n\r\n      class App extends Component {\r\n          render() {\r\n              let contacts = api.getAll() ;    // NEW\r\n              return (    \r\n                  <div className=\"jumbotron\">\r\n                      <Header noContacts={contacts.length} />\r\n                      <ContactForm />\r\n                      <ContactList contacts={contacts}  />  \r\n                  </div>\t\t              \r\n                  );\r\n          }\r\n      }\r\n\r\n    export default App;\r\n\r\nThe app should now render in the browser as before.\r\n\r\n![][app]\r\n\r\nFrom the `contactlist` folder update the local Git repo:\r\n\r\n    $ git add -A\r\n    $ git commit -m \"Added stub API\"\r\n\r\nRestart the development server. \r\n\r\n### UI state.\r\n\r\nIn React terms, a common source of UI state is user input controls, including:\r\n\r\n+ Input Text field.\r\n+ Drop-down menu.\r\n+ Radio button or checkbox.\r\n\r\nAn analysis of this app's behavior requirements gives the following UI state breakdown:\r\n\r\n1. Contact details - A contact's properties (name, address, etc) are editable and therefore should be stored as UI state.\r\n1. New contact details - The input fields on the Add contact mini form are UI state.\r\n1. Contact status - A contact's 'status' changes when the user clicks the Edit or Delete button. The change is reflected in the label, color and meaning of its two buttons. Three status types are possible: Normal (default); Edit (button labels change to Undo and Save); and Delete (button labels change to Confirm and Cancel). As a status change results from user input, it maps to React's *component state* concept.\r\n\r\n### Stateful components.\r\n\r\nWhich components should manage the app's UI state? \r\n\r\nOnly the Contact component is concerned about the status attribute. Also, no other component needs to be re-rendered while the user is editing/updating a contact. The web Form component can manage the new contact's details while they are being entered. When the user submits the data it is only then the App components needs to be informed.\r\n\r\nIn `src/components/contact.js`, change the Contact component as shown below:\r\n\r\n      class Contact extends Component {\r\n          state = {\r\n            status : '',\r\n            name: this.props.contact.name,\r\n            address: this.props.contact.address,\r\n            phone_number: this.props.contact.phone_number,\r\n            previousDetails: {\r\n              name: this.props.contact.name,\r\n              address: this.props.contact.address,\r\n              phone_number: this.props.contact.phone_number  \r\n            }\r\n          };\r\n          render() {\r\n              . . . as before . . .\r\n          }\r\n      }\r\n\r\nNotes:\r\n\r\n1. For simplicity, the normal (default) contact status will be represented by an empty string. The values 'edit' and 'del' will be used for the other status options - see later.\r\n1. The initial values for a contact's details are passed in as props. While props are not normally stored as state, it is necessary here to support the edit feature.\r\n1. The previousDetails nested object is necessary to support the undo operation of the edit feature - we need to reset the contact's properties back to pre-edit values.\r\n\r\n#### Externalize configuration.\r\n\r\nThe attributes (color, label) of the buttons associated with a contact could be considered __configuration data__. It is good practice to separate configuration from logic, thus making an app easier to reconfigure. Create the file  `src/config/buttonsConfig.js` and add the following code:\r\n\r\n      let buttons = {\r\n         normal : { \r\n            leftButtonVal : 'Edit',\r\n            rightButtonVal : 'Delete',\r\n            leftButtonColor : 'btn-default',\r\n            rightButtonColor : 'btn-danger'\r\n         },\r\n         delete : { \r\n            leftButtonVal : 'Undo' ,\r\n            rightButtonVal : 'Confirm' ,\r\n            leftButtonColor : 'btn-success',\r\n            rightButtonColor : 'btn-danger'\r\n         },\r\n         edit : {\r\n            leftButtonVal : 'Save' ,\r\n            rightButtonVal : 'Cancel' ,\r\n            leftButtonColor : 'btn-danger',\r\n            rightButtonColor : 'btn-success'\r\n         }\r\n      }\r\n      export default buttons;\r\n\r\nThis configuration data is used in the next section.\r\n\r\n### Adding dynamic behavior.\r\n\r\nWe will start by adding support for a contact's Edit button. The code will involve the following:\r\n\r\n1. Change the Contact component's status to 'edit'. \r\n1. Keep the contact details stored in the state object in sync with the text input fields as the user is typing. React's *onChange* event will facilitate synchronization.\r\n1. If the user cancels an edit operation then the contact's details must be reset.\r\n\r\nSignificant changes are required to `components/contact.js`. Update its content as detailed below:\r\n\r\n    . . . . other imports . . . . \r\n    import buttons from '../config/buttonsConfig';\r\n    import _ from 'lodash';\r\n    import api from '../dataStore/stubAPI'\r\n\r\n    class Contact extends Component {\r\n        state = { . . . as before . . . };\r\n        handleEdit = () =>  this.setState({ status : 'edit'} );\r\n        handleSave = (e) =>  null ;  // Implemented later\r\n        handleCancel = () => {\r\n          let {name, address, phone_number} = this.state.previousDetails ;\r\n          this.setState({ status : '', \r\n              name, address, phone_number } ) ;\r\n        }; \r\n        handleNameChange = (e) =>  this.setState({name: e.target.value});\r\n        handleAddressChange = (e) => this.setState({address: e.target.value});  \r\n        handlePhoneNumChange = (e) =>  \r\n                  this.setState({phone_number: e.target.value});             \r\n        render() {\r\n              let activeButtons = buttons.normal ;\r\n              let leftButtonHandler = this.handleEdit;\r\n              let rightButtonHandler = this.handleDelete;\r\n              if (this.state.status === 'edit' ) {\r\n                  activeButtons = buttons.edit ;\r\n                  leftButtonHandler = this.handleSave;\r\n                  rightButtonHandler = this.handleCancel ;\r\n              }    \r\n              return (\r\n                <div className=\"col-sm-3\" >\r\n                  <div className=\"panel panel-primary\">\r\n                      <div className=\"panel-heading\">\r\n                          { this.state.name }\r\n                      </div>\r\n                      <div className=\"panel-body\">\r\n                      {  this.state.status === 'edit' ? \r\n                          [ \r\n                          <input type=\"text\" className=\"form-control\"\r\n                              value={this.state.name}\r\n                              onChange={this.handleNameChange} />,\r\n                          <input type=\"text\" className=\"form-control\"\r\n                              value={this.state.address}\r\n                              onChange={this.handleAddressChange} />,\r\n                          <input type=\"text\" className=\"form-control\"\r\n                              value={this.state.phone_number}\r\n                              onChange={this.handlePhoneNumChange} />\r\n                          ] :\r\n                          [\r\n                              <p key={'name'}>{this.state.name}</p>,\r\n                              <p key={'address'} >{this.state.address}</p>,\r\n                              <p key={'phone_number'} >{this.state.phone_number}</p>,\r\n                          ]   \r\n                      }        \r\n                      </div>\r\n                      <div className=\"panel-footer\"> \r\n                        <div className=\"btn-group btn-group-justified\" role=\"group\" aria-label=\"...\">\r\n                          <div className=\"btn-group\" role=\"group\">\r\n                              <button type=\"button\" \r\n                                  className={'btn ' + activeButtons.leftButtonColor} \r\n                                  onClick={leftButtonHandler} >\r\n                                  {activeButtons.leftButtonVal}\r\n                              </button>\r\n                          </div>\r\n                          <div className=\"btn-group\" role=\"group\">\r\n                              <button type=\"button\" \r\n                                  className={'btn ' + activeButtons.rightButtonColor} \r\n                                  onClick={rightButtonHandler} >\r\n                                  {activeButtons.rightButtonVal}\r\n                              </button>  \r\n                          </div>\r\n                      </div>                     \r\n                      </div>          \r\n                  </div>\r\n                </div>\r\n              ) ; \r\n            }\r\n        } \r\n        export default Contact;\r\n\r\n\r\nNotes:\r\n\r\n1. ES6 arrow functions have 'this' bound to the containing object. \r\n1. In ES6, for single-line anonymous functions the curly-braces are optional and the return keyword is omitted.\r\n1. In edit mode, the Contact component's data fields change from non-editable text to input fields. The ternary operator (?:) is used inside the above JSX to implement the conditional switch. The JSX (and ultimately HTML) is being __dynamically computed__ based on the status property of the state object.\r\n1. We use this.state instead of this.props to set the value of an input field. This ensures the state object is in sync with the current input.    \r\n1. The save changes feature is not implemented, yet.\r\n\r\nTo test the above code, click the Edit button of any contact. \r\n\r\n![][edit]\r\n\r\nThe contact's details are now editable. Change some values (say, address) and click Cancel to reset it.\r\n\r\nTo get save working, implement the *handleSave*, as follows:\r\n\r\n    class Contact extends Component {\r\n        . . . . . . \r\n        handleSave = (e) => {\r\n            e.preventDefault();\r\n            let updatedName = this.state.name.trim();\r\n            let updatedAddress = this.state.address.trim();\r\n            let updatedPhone_number = this.state.phone_number.trim();\r\n            if (!updatedName || !updatedAddress || !updatedPhone_number ) {\r\n                return ;\r\n            }\r\n            let {name, address, phone_number} = this.state ;\r\n            this.setState({status : '',\r\n                previousDetails: { name, address, phone_number  }\r\n            })\r\n            api.update( this.state.previousDetails.phone_number,\r\n                updatedName , updatedAddress, updatedPhone_number )\r\n        };                              \r\n        handleCancel = (e) => { . . .  as before . . . }\r\n\r\nNow try editing a contact and saving the changes.\r\n\r\n### Inverse data flow.\r\n\r\nTo implement the Delete contact feature we need to follow the inverse data flow design pattern. For a Delete action the Contact component must request the App component to complete the delete, via the stub API. The App then re-renders itself to ensure the 'number of contacts' badge is updated. The elements of the inverse data flow pattern includes:\r\n\r\n+ A function in App to communicate with the API and perform re-rendering.\r\n+ Pass a reference to above function to the Contact components. \r\n+ Contact component invokes the function when required. \r\n\r\n[ The re-rendering by the App component does lead to some unnecessary re-rendering by the Contact components. We will remove this unnecessary execution later.]\r\n\r\nIn `src/App.js`, make the following changes:\r\n\r\n      .\r\n      .\r\n      .\r\n      class App extends Component {\r\n          deleteContact = (key) => {\r\n              api.delete(key); \r\n              this.setState({});                          \r\n          };\r\n\r\n          render() {\r\n                . . . . as before . .  .\r\n                return (\r\n                    . . . as before . . . \r\n                    <ContactList contacts={contacts} \r\n                          deleteHandler={this.deleteContact} />\r\n                    . . . as before . . . \r\n            );\r\n        }\r\n      }\r\n      export default App;\r\n\r\nIn `components/contactList.js` make the following changes:\r\n\r\n      export default class ContactList extends Component {\r\n          render() {\r\n            let contactPanels =   this.props.contacts.map(\r\n                (c) => <Contact key={c.phone_number} contact={c} \r\n                          deleteHandler={this.props.deleteHandler} /> \r\n            );\r\n            return (\r\n                . . . . as before . . . .\r\n              ) ;\r\n          }\r\n      }\r\n\r\nThe final change is to complete the data flow pattern, in  `components/contact.js`:\r\n\r\n       . . . . . . \r\n       class Contact extends Component {\r\n          . . . . other handlers . . . . \r\n          handleDelete = () =>  this.setState({ status : 'del'} );\r\n          handleConfirm = (e) => {\r\n            e.preventDefault();\r\n            this.props.deleteHandler(this.state.phone_number);\r\n          };\r\n          render() { \r\n              . . . . . . . \r\n             if (this.state.status === 'edit' ) {\r\n                 . . . as before . . . \r\n             } else if (this.state.status === 'del' ) {\r\n                activeButtons = buttons.delete ;\r\n                leftButtonHandler = this.handleCancel ;\r\n                rightButtonHandler = this.handleConfirm;\r\n             }\r\n             return ( . . . as before . . . )   \r\n      }\r\n      export default Contact;\r\n\r\nNote, for convenience we are using a contact's phone number as a unique key/ identifier. In the browser, test the Delete feature.\r\n\r\nFrom the `threeApps/contactlist` folder commit this work:\r\n\r\n     $ git add -A\r\n     $ git commit -m \"Edit and Delete features completed\"\r\n\r\n### Add Contact,\r\n\r\nThe mini web form to add a new contact is the remaining feature. The inverse data flow pattern applies here also, in that we need:\r\n\r\n+ A function in App to pass the new contact details to the API and perform a re-rendering.\r\n+ To pass a reference to above function to the ContactForm component. \r\n+ ContactForm component invokes the function when required.\r\n\r\nIn `src/App.js` make the following changes:\r\n\r\n       . . . . imports . . . . \r\n\r\n       class App extends Component {\r\n          addContact = (n, a, p) => {\r\n               api.add(n,a,p) ;\r\n               this.setState({});\r\n          };\r\n          deleteContact = ..... as before .....\r\n\r\nand in the render method of the same component, pass this new function to the form component:\r\n\r\n         . . . . .. \r\n         <ContactForm  addHandler={this.addContact} />\r\n         . . . . . . \r\n\r\nIn a React app, data entry fields must be managed by your code (for HTML-based forms the browser DOM does it). The approach is to store a field's value in state and update it on every key press. In `components/contactForm.js` replace the entire code with the following: \r\n\r\n      import React , { Component } from 'react';\r\n\r\n      class ContactForm extends Component {\r\n          state = { name: '', address: '', phone_number : ''};\r\n          handleSubmit = (e) => {\r\n            e.preventDefault();\r\n            let name = this.state.name.trim();\r\n            let address = this.state.address.trim();\r\n            let phone_number = this.state.phone_number.trim();\r\n            if (!name || !address || !phone_number) {\r\n                return;\r\n            }\r\n            this.props.addHandler(name,address,phone_number);\r\n            this.setState({name: '', address: '', phone_number: ''});\r\n        }\r\n          handleNameChange = (e) =>  this.setState({name: e.target.value});\r\n          handleAddressChange = (e) => this.setState({address: e.target.value});\r\n          handlePhoneNumChange = (e) =>  this.setState({phone_number: e.target.value});\r\n\r\n          render() {\r\n              return (\r\n                  <div className=\"container-fluid\">\r\n                      <div className=\"row\">\r\n                      <div className=\"col-sm-2\" >\r\n                         <button type=\"button\" className=\"btn btn-success\"\r\n                             onClick={this.handleSubmit} >Add Contact</button>\r\n                      </div>              \r\n                      <div className=\"col-sm-3\" >\r\n                        <input type=\"text\" className=\"form-control\" \r\n                            placeholder=\"Name\"\r\n                            value={this.state.name}\r\n                            onChange={this.handleNameChange}\r\n                        />\r\n                      </div>\r\n                      <div className=\"col-sm-3\" >\r\n                        <input type=\"text\" className=\"form-control\"\r\n                            placeholder=\"Address\"\r\n                            value={this.state.address}\r\n                            onChange={this.handleAddressChange}\r\n                        />\r\n                      </div>\r\n                      <div className=\"col-sm-2\" >\r\n                        <input type=\"text\" className=\"form-control\" \r\n                            placeholder=\"Phone No.\"\r\n                            value={this.state.phone_number}\r\n                            onChange={this.handlePhoneNumChange}\r\n                        />\r\n                      </div>                             \r\n                    </div>\r\n                  </div>\r\n              );\r\n          }\r\n      }\r\n      export default ContactForm;\r\n\r\nIn the browser, test the feature works.\r\n\r\nOn completion, commit the work:\r\n\r\n     $ git add -A\r\n     $ git commit -m \"Add contact completed\"\r\n                  \r\n[app]: ./img/app.png\r\n[edit]: ./img/edit.png\r\n[solution]: ./index.html#/Solutions"
    },
  
    {
    "title": "## Phone Catalogue App.",
    "shortTitle": "Phone_Catalogue",
    "contentMd" : "## Phone Catalogue App.\r\n\r\nIn this app when the user enters text in the search field it should display only those phones whose name contains the entered text. Also, the order of the list of matching phones should change when the drop-down menu options is changed.\r\n\r\nFrom `threeApps/phonecatalogue` folder, install the lodash package:\r\n\r\n         $ npm install  lodash@2.4.2 --save\r\n\r\nStart the development server:\r\n\r\n         $ npm start \r\n\r\n### UI state.\r\n\r\nThe UI state for this application consists of:\r\n \r\n1. The search text - Every character typed in the text box will require a recalculation of the matching subset of phones.\r\n1. The Sort drop-down menu selection - Changes the ordering of the current matching subset of phone.\r\n\r\n### Stateful components.\r\n\r\nBoth the SelectControls and App components need to know the current search text value. SelectControls uses it to set the text input field value, while App uses it to compute the matching subset of phones. As App is higher up the component hierarchy, it should manage this state value. The same argument can be made for the sort drop-down menu selection.\r\n\r\nIn `phonesCatalogue/src/App.js`, add a state object, as follows:\r\n\r\n      class App extends Component {\r\n        state = { search: '', sort: 'name' };\r\n        render() {\r\n            . . . as before . . .\r\n        }\r\n      }\r\n\r\n### Adding dynamic behavior.\r\n\r\nWe need to implement inverse data flow between the App and SelectControls components. In `src/components/selectControls/index.js`, completely replace its content with the following code:\r\n\r\n    import React, { Component } from 'react';\r\n\r\n     export default class SelectControls extends Component {\r\n        handleChange = (e, type, value) => {\r\n            e.preventDefault();\r\n            this.props.onUserInput(type, value);\r\n        };\r\n        handleTextChange = (e) => {\r\n            this.handleChange( e, 'search', e.target.value);\r\n        };\r\n        handleSortChange = (e) => {\r\n            this.handleChange(e, 'sort', e.target.value);\r\n        };\r\n\r\n        render() {\r\n            return (\r\n                <div className=\"col-md-10\">\r\n                    <input type=\"text\" placeholder=\"Search\" \r\n                        value={this.props.filterText}\r\n                        onChange={this.handleTextChange} />\r\n                    <span> Sort by: </span>\r\n                    <select id=\"sort\" value={this.props.order } \r\n                        onChange={this.handleSortChange} >\r\n                        <option value=\"name\">Alphabetical</option>\r\n                        <option value=\"age\">Newest</option>\r\n                    </select>\r\n                </div>\r\n            );\r\n        }\r\n      }\r\n\r\nNote, the handlerChange function calls a props function (not yet defined) belonging to the App component. The App function updates the state object, re-computation of the matching phone list, and forces a re-rendering. Make the following changes to `src/App.js`:\r\n\r\n      class App extends React.Component {\r\n        state = { . . . as before . . . };\r\n\r\n        handleChange = (type, value) => {\r\n            type === 'search' ?\r\n                this.setState( { search: value } ) :\r\n                this.setState( { sort: value } ) ;\r\n        };\r\n\r\n        render() {\r\n            console.log( \r\n                `Criteria: Search=  ${this.state.search} ; Sort= ${this.state.sort}`);\r\n            let filteredList = Phones ; // Incomplete\r\n            return (\r\n              <div className=\"jumbotron\">\r\n                  <div className=\"container-fluid\">\r\n                    <div className=\"row\">\r\n                     <div className=\"col-md-10\">\r\n                        <h2>Phone Catalogue App</h2>\r\n                     </div>\r\n                     <SelectControls onUserInput={this.handleChange } \r\n                            filterText={this.state.search} \r\n                            sort={this.state.sort} />\r\n                     <PhoneList phones={filteredList} />\r\n                  </div> \r\n                </div>                   \r\n             </div>\r\n            );\r\n        }\r\n      }\r\n\r\nThis code is incomplete because the subset of matching phones is not being recomputed, however, the `console.log()` statement in the render method allows us verify the 'inverse data flow' is working. To prove it, in the browser, open the Chrome developer tools. Now type 'sam' in the search text field and select 'Newest' in the sort dropdown. The screenshot below shows the console output. \r\n\r\n![][console]\r\n\r\nIn `src/App.js`, add the import  at the top:\r\n\r\n  \t\timport _ from 'lodash';\r\n\r\nand update the App component's render method, as shown:\r\n\r\n        render() {\r\n            let list = Phones.filter( \r\n                (p) => \r\n                p.name.toLowerCase().search(this.state.search.toLowerCase()) !== -1 \r\n            );\r\n            let filteredList = _.sortBy(list, this.state.sort) ;\r\n            return ( . . . as before . . . );\r\n        }\r\n\r\nThe features used above include:\r\n\r\n1. The array *filter* method - creates a new array consisting of those entries in the source (this.props.phones) for which the arrow function returns true.\r\n1. The string *search* method - returns the position of a substring (this.state.search) within a source string (p.name); otherwise, returns -1 when not present.\r\n1. The lodash *sortBy* utility function.\r\n\r\nIn the browser check the app is fully-functional by using the search text and drop-down menu inputs.\r\n\r\n### Storybook addons.\r\n\r\nStorybook can accommodate components that expect a function prop by providing a stub replacement. We use an addon to implement the stub.  Add the following line to the configuration file `.storybook/addons.js`:\r\n\r\n      import '@storybook/addon-actions/register';\r\n \r\n In `stories/phoneApp.js` add a new import at the top:\r\n\r\n      import { action } from '@storybook/addon-actions';\r\n\r\nand update the related story:\r\n\r\n        storiesOf('Phone Catalogue', module)\r\n            .add('Select controls', \r\n              () =>   <SelectControls \r\n                        onUserInput={ action('input changed') }\r\n                        filterText='' /> \r\n            )\r\n            .add('Phone', . . . . as before . . . . \r\n\r\nWe are passing a dummy function (or action ) to the SelectControls component. The dummy will simply display a message ('input changed') when invoked.  Start the server:\r\n\r\n      $ npx start-storybook -s ./public -p 9001 -c .storybook\r\n\r\nBrowse to http://localhost:9001/ , select the story, and in the component change the drop-down menu selection and type in the search field. Confirmation of the dummy function calls can be seen in the 'Action Logger' panel.\r\n\r\n![][story]\r\n\r\nsee [here][addons] for a full list of Storybook addons.\r\n\r\nCommit these changes to git:\r\n\r\n        $ git add -A\r\n        $ git commit -m \"Search page completed\"\r\n     \r\n\r\n[console]: ./img/console.png   \r\n[story]: ./img/phonestory.png   \r\n[addons]: https://storybook.js.org/addons/addon-gallery/"
    },
  
    {
    "title": "## Hacher News.",
    "shortTitle": "Hacker_News",
    "contentMd" : "## Hacher News.\r\n\r\n### Setup.\r\n\r\nFrom `threeApps/hackerNews`, install the lodash packages:\r\n\r\n         $ npm install  lodash@2.4.2 --save\r\n\r\nFrom the same folder start the server:\r\n\r\n         $ npm start \r\n\r\n### Stub API\r\n\r\nAgain we will use a stub API as the model data source. Create the file `hackerNews/src/dataStore/stubAPI.js` and paste in the following code:\r\n\r\n\timport _ from 'lodash';\r\n\r\n\tclass StubAPI {\r\n\t\tconstructor() {\r\n\t\t\tthis.posts = [\r\n\t\t\t\t{  id: 1 ,\r\n\t\t\t\t\ttitle : 'India - Tiger population sees 30% increase.',\r\n\t\t\t\t\tlink : 'http://www.bbc.com/news/world-asia-30896028',\r\n\t\t\t\t\tusername : 'jbloggs',\r\n\t\t\t\t\tcomments : [],\r\n\t\t\t\t\tupvotes : 10\r\n\t\t\t\t},\r\n\t\t\t\t{ \r\n\t\t\t\t\tid: 2,\r\n\t\t\t\t\ttitle : 'The button that is not.',\r\n\t\t\t\t\tlink : 'http://blog.nuclearsecrecy.com/2014/12/15/button-isnt/',\r\n\t\t\t\t\tusername : 'notme',\r\n\t\t\t\t\tcomments : [],\r\n\t\t\t\t\tupvotes : 12\r\n\t\t\t\t},\r\n\t\t\t\t{ \r\n\t\t\t\t\tid: 3,\r\n\t\t\t\t\ttitle : 'Google Nears $1B Investment in SpaceX',\r\n\t\t\t\t\tlink : null,\r\n\t\t\t\t\tusername : 'notme',\r\n\t\t\t\t\tcomments : [],\r\n\t\t\t\t\tupvotes : 12\r\n\t\t\t\t},\r\n\t\t\t\t{ \r\n\t\t\t\t\tid: 4,\r\n\t\t\t\t\ttitle : 'Coinbase Raises $75M from DFJ Growth, USAA, and More',\r\n\t\t\t\t\tlink : 'http://blog.coinbase.com/post/108642362357/coinbase-raises-75m-from-dfj-growth-usaa-nyse',\r\n\t\t\t\t\tusername : 'psmith',  \r\n\t\t\t\t\tcomments : [],\r\n\t\t\t\t\tupvotes : 2\r\n\t\t\t\t}\r\n\t\t\t] ;\r\n\t\t}\r\n\r\n\t\tgetAll() {\r\n\t\t\treturn this.posts ;\r\n\t\t}\r\n\r\n\t\tadd(title, link) {\r\n\t\t\tlet id = 1 ;\r\n\t\t\tlet last = _.last(this.posts) ;\r\n\t\t\tif (last) {\r\n\t\t\t\tid = last.id + 1 ;\r\n\t\t\t}\r\n\t\t\tlet len = this.posts.length ;\r\n\t\t\tlet newLen = this.posts.push({ \r\n\t\t\t\tid, title, link, \r\n\t\t\t\tusername: '', \r\n\t\t\t\tcomments: [], \r\n\t\t\t\tupvotes: 0 }) ;\r\n\t\t\treturn newLen > len ;\r\n\t\t}\r\n\r\n\t\tupvote(id) {\r\n\t\t\tlet index = _.findIndex(this.posts, \r\n\t\t\t\t(post) => post.id === id\r\n\t\t\t);   \r\n\t\t\tif (index !== -1) {                 \r\n\t\t\t\tthis.posts[index].upvotes += 1 ;\r\n\t\t\t\treturn true ;\r\n\t\t\t}\r\n\t\t\treturn false ;\r\n\t\t}\r\n\r\n\t\tgetPost(id) {\r\n\t\t\tlet index = _.findIndex(this.posts, \r\n\t\t\t\t(post) => post.id === id\r\n\t\t\t)   \r\n\t\t\tlet result = index !== -1 ?                  \r\n\t\t\t\tthis.posts[index] :\r\n\t\t\t\tnull ;\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\taddComment(postId,c,n) {\r\n\t\t\tlet post = this.getPost(postId ) ;\r\n\t\t\tlet id = 1 ;\r\n\t\t\tlet last = _.last(post.comments) ;\r\n\t\t\tif (last) {\r\n\t\t\t\tid = last.id + 1 ;\r\n\t\t\t}\r\n\t\t\tpost.comments.push({ 'id': id,  \r\n\t\t\t\tcomment: c , author: n, upvotes: 0 } ) ;\r\n\t\t}\r\n\r\n\t\tupvoteComment(postId,commentId) {\r\n\t\t\tlet post = this.getPost(postId ) ;\r\n\t\t\tlet index = _.findIndex(post.comments, \r\n\t\t\t\t(c) => c.id === commentId\r\n\t\t\t);  \r\n\t\t\tif (index !== -1) {                 \r\n\t\t\t\tpost.comments[index].upvotes += 1 ;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\texport default (new StubAPI() );\r\n\r\nNote: An __id__ has been added to each post (news item) object for convenience. The add method of the API computes the id of a new post by simply adding 1 to the id of the last one in the array. The upvote method is passed the id of the post to be upvoted.\r\n\r\nIn `src/App.js` completely replace the current code with the following:\r\n\r\n        import React, { Component } from 'react';\r\n        import NewsList from './components/newsList';\r\n        import Form from './components/newsForm';\r\n        import api from './dataStore/stubAPI';\r\n\r\n        export default class App extends Component {\r\n        \r\n            render() {\r\n                let posts =  api.getAll();\r\n                return (\r\n                  <div className=\"jumbotron\">\r\n                    <div className=\"container-fluid\">\r\n                      <div className=\"row\">\r\n                        <div className=\"col-md-9 col-md-offset-3\" >\r\n                            <a href=\"/\"><h1>Hacker News</h1></a>\r\n                        </div>\r\n                      </div>\r\n                    </div>\r\n                    <div className=\"container\">\r\n                       <div className=\"row\">\r\n                          <div className=\"col-md-9 col-md-offset-1\">\r\n                            <NewsList posts={posts}  />\r\n                            <Form />\r\n                          </div>\r\n                       </div>\r\n                    </div>\r\n                </div>\r\n                );\r\n            }\r\n        }\r\n\r\nThe browser should render the news items as before.\r\n\r\n### Dynamic behaviour.\r\n\r\nWe will add the upvoting feature first. In `src/App.js` add a new function:\r\n  \r\n\texport default class App extends Component {\r\n\t\tincrementUpvote = (id) => {\r\n\t\t\tapi.upvote(id) ;\r\n\t\t\tthis.setState({});\r\n\t\t};\r\n\t\r\n       render() {\r\n           . . . . . . \r\n               <NewsList posts={posts} \r\n                    upvoteHandler={this.incrementUpvote} />\r\n           . . . . . . \r\n      }\r\n\r\nThis function is called when the user clicks a thumb-up glyph. Therefore it must be passed down the component hierarchy to NewsItem. In `components/newsList/index.js`, update the NewsItem set of props:\r\n\r\n    render() {\r\n        let items = this.props.posts.map(\r\n            (post,index) => \r\n                <NewsItem key={index} \r\n                    post={post} \r\n                    upvoteHandler={this.props.upvoteHandler} /> \r\n        );\r\n        return ( . . . as before . . )\r\n\r\nIn `components/newsItwm/index.js`, add the onClick handler:\r\n\r\n        export default class NewsItem extends Component {\r\n            handleVote = () =>  this.props.upvoteHandler(this.props.post.id);\r\n\r\n            render() {\r\n                . . . . . . \r\n                return (\r\n                   . . . . .\r\n                    <span className=\"glyphicon glyphicon-thumbs-up ptr\" \r\n                          onClick={this.handleVote}/>\r\n                    {this.props.post.upvotes}\r\n                   . . . . . . . . \r\n                \r\nIn the browser you should now be able to increment a news item's upvote count. We also want the items to be in descending order, by vote count. In `src/App.js` compute the order in the render method:\r\n\r\n         . . . . imports . . . \r\n        import _ from 'lodash';\r\n        . . . . . . .\r\n        render() {\r\n           let posts = _.sortBy(api.getAll(), \r\n                (post) => - post.upvotes\r\n           );\r\n           return ( \r\n                . . . as before . . \r\n\r\nIn the browser upvote an item a few times to force a reordering.\r\n\r\nFrom the `threeApps/hackerNews` folder, commit the work so far:\r\n\r\n     $ git add -A\r\n     $ git commit -m \"Upvote feature completed\"\r\n\r\n### Add news item.\r\n\r\nThe add news item feature is very similar to the add contact feature in the Contact List app. We need the following:\r\n\r\n+ A state object in the NewsForm component to store the current values being typed into the form fields.\r\n+ A function to pass the new item to the API and force a re-rendering.\r\n    + The function needs to be part of the App component.\r\n\r\nIn `src/App.js` make the following changes:\r\n\r\n\r\n    export default class App extends Component {\r\n        addNewsItem = (title,link) => {\r\n            api.add(title,link)\r\n            this.setState({})\r\n        }\r\n        incrementUpvote = (id) => { . . . as before }\r\n\r\nand in the render method change the Form tag:\r\n\r\n        <Form handleAdd={ this.addNewsItem } />\r\n\r\n#### Exercise.\r\n\r\nYou are required to complete the implementation. The code that needs modifying is `components/newsForm/index.js` - use the Add contact form from the Contact List App  as a guide.\r\n\r\n\r\n### Storybook.\r\n\r\nFor completeness we should update the Storybook code for the NewsForm component/ \r\nIn `.storybook/addons.js` register the addon-action plugin:\r\n\r\n      import '@storybook/addon-actions/register';\r\n\r\nIn `stories/hackerApp.js` import the plugin:\r\n\r\n      import { action } from '@storybook/addon-actions';\r\n\r\n#### Exercise.\r\n\r\nYou are required to update the effected story in `stories/hackerApp.js`.\r\n\r\nWhen completed, start the Storybook server and test it in the browser. Fill out the form and click the Add button. The screenshot shows a sample result.\r\n\r\n![][newsstory]\r\n\r\n----------------------------\r\n\r\nOn completion, go to the `hackerNews` folder and commit the work:\r\n\r\n     $ git add -A\r\n     $ git commit -m \"Add news item feature completed\"\r\n\r\n\r\n[newsstory]: ./img/newsstory.png"
    }
  
  ]
  }

